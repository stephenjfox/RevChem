# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_exploration_tobii.ipynb.

# %% auto 0
__all__ = ['parse_list', 'iter_parse_raw_data', 'GazeInfo', 'Iterated']

# %% ../nbs/00_exploration_tobii.ipynb 36
from json import loads as load_json_str
from typing import Any, Iterable

def parse_list(text: str, start_index: int) -> tuple[int, list]:
    "parse a list out of the text, returning a tuple of (index after the list, the list)"
    ends = [("[", start_index)]
    ind = start_index + 1
    while ends:
        match text[ind]:
            case "\"": ends.append('"')
            case "'": ends.append('"')
            case "[": ends.append("[")
            case "{": ends.append("{")
            case _: None

def iter_parse_raw_data(raw_data: str) -> Iterable[Any]:
    def test_numbers_str_invariant(numbers: str):
        if not isinstance(numbers, str):
            raise TypeError("Numbers string should be a str")
        if not numbers:
            raise ValueError(f"Receive {numbers} for argument 'numbers', excepted value")
        if "," not in numbers:
            raise IndexError(f"Could not find comma in list argument {numbers}")
    
    def numbers_string_to_list(numbers: str) -> list[int|float]:
        return [
            num_int if (num_int := int(num_str)) == (num_f := float(num_str)) else num_f
            for num_str in numbers.split(",")
        ]

    # assuming a list of lists,
    # convert from "[[...],[...],[...],[...]]" -> "...],[...],[...],[..."
    text_data_of_listlists = raw_data[2:-2].replace(" ", "") # delete whitespace
    # to ease the algorithm to follow
    CONST_SPLIT_TARGET = "],["
    (numbers, rest) = split_res = text_data_of_listlists.split(CONST_SPLIT_TARGET, maxsplit=1) # one at a time.
    
    while split_res:
        test_numbers_str_invariant(numbers)
        yield numbers_string_to_list(numbers)

        split_res = rest.split(CONST_SPLIT_TARGET, maxsplit=1) # one at a time.
        match split_res:
            case [_, _]:
                # iterate again
                # print(f"Iterate: {numbers = }")
                (numbers, rest) = split_res
            case [numbers,]: 
                # final iteration, yield the last list
                # print(f"Final: {numbers = }")
                yield numbers_string_to_list(numbers)
                split_res = None # terminate loop condition
            case _:
                raise ValueError(f"Should be unreachable state: {split_res = }")

# %% ../nbs/00_exploration_tobii.ipynb 44
from dataclasses import dataclass

@dataclass
class GazeInfo:
    """GazeInfo object from RealEye, with
    - "gaze point" being a coordinate pair of where the participant's eyes were looking.
    - "mouse pos" coordinate pair
    """
    gaze_point_X: int
    gaze_point_Y: int
    time_ms_since_start: int
    scroll_offset_Y: float # scoll offset if you scrolled the screen
    mouse_pos_X: float
    mouse_pos_Y: float

# %% ../nbs/00_exploration_tobii.ipynb 48
from functools import reduce
from typing import NamedTuple

class Iterated:
    @staticmethod
    def _reduce_helper_sum_and_count(init, arg):
        "Reducer for enumerated iterable of summable values"
        return (arg[0], arg[1] + init[1])

    @staticmethod
    def mean(iterable: Iterable[int|float]) -> float:
        count, s_ = reduce(Iterated._reduce_helper_sum_and_count, enumerate(iterable), (0, 0))
        return s_ / count if count else 0

    @staticmethod
    def resettable_iter_raw(raw_gazes: dict[str, str]):
        class Resettable(NamedTuple):
            it: Iterable
            def iter(self) -> Iterable[tuple[int, int, int, float, float, float]]:
                return iter_parse_raw_data(self.it)

        return Resettable(raw_gazes)

